<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pongo Game</title>
    <link rel="stylesheet" href="/assets/pongo/dist/styles.css">
    <link rel="icon" type="image/svg+xml" href="/assets/pongo/favicon.svg">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="/socket.io/socket.io.js"></script>

    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background: #0f0c29;
            background: -webkit-linear-gradient(to right, #24243e, #302b63, #0f0c29);
            background: linear-gradient(to right, #24243e, #302b63, #0f0c29);
            color: #ffffff;
            overflow: hidden; /* Prevent scrollbars */
        }
        canvas {
            background-color: rgba(0, 0, 0, 0.5);
            display: block;
            border: 2px solid #00ffff;
            box-shadow: 0 0 25px #00ffff, inset 0 0 15px rgba(0, 255, 255, 0.5);
            border-radius: 10px;
            cursor: none; /* Hide cursor over canvas */
        }
        .title, .score-label {
             color: #00ffff;
             text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
        }
        .score {
            color: #ffffff;
            text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff;
        }
        .message-box {
            background-color: rgba(0, 0, 0, 0.6);
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
            backdrop-filter: blur(5px);
        }
        .restart-btn {
            background-color: #00ffff;
            color: #0f0c29;
            text-shadow: none;
            box-shadow: 0 0 15px #00ffff;
            transition: all 0.3s ease;
        }
        .restart-btn:hover {
            background-color: #ffffff;
            color: #000;
            box-shadow: 0 0 25px #ffffff;
        }
        #muteButton {
            text-shadow: 0 0 10px #00ffff;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">
    <script>
      // Parse clean URL: /:app/:roomId â†’ expose for multiplayer clients
      (function(){
        try {
          const parts = (location.pathname || '/').split('/').filter(Boolean);
          window.APP_SLUG = parts[0] || 'pongo';
          window.ROOM_ID = parts[1] || 'default';
          console.log('App/Room:', window.APP_SLUG, window.ROOM_ID);
        } catch {}
      })();
    </script>


    <h1 class="text-5xl mb-4 title">PONG</h1>

    <div class="flex w-full max-w-4xl justify-around mb-4">
        <div class="text-center">
            <h2 class="text-2xl score-label">PLAYER</h2>
            <p id="player-score" class="text-6xl score">0</p>
        </div>
        <div class="text-center">
            <h2 class="text-2xl score-label">COMPUTER</h2>
            <p id="computer-score" class="text-6xl score">0</p>
        </div>
    </div>

    <!-- Speed control -->
    <div class="w-full max-w-4xl mb-6 text-center">
        <label for="speedSlider" class="score-label">Ball Speed</label>
        <div class="mt-2 flex items-center justify-center gap-4">
            <input id="speedSlider" type="range" min="0.5" max="2.0" step="0.05" value="1.0" style="width:420px;">
            <span id="speedValue" class="score">1.00x</span>
        </div>
    </div>

    <div class="relative">
        <canvas id="pongCanvas"></canvas>
        <button id="muteButton" class="absolute top-4 right-4 text-white text-3xl focus:outline-none opacity-75 hover:opacity-100 transition-opacity">ðŸ”Š</button>
    </div>

    <!-- Start Overlay (required for autoplay policies) -->
    <div id="startOverlay" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
        <div class="message-box rounded-lg p-8 text-center">
            <p class="text-2xl mb-6 text-white" style="text-shadow: 0 0 10px #00ffff;">Click Start to enable sound</p>
            <button id="startButton" class="restart-btn py-3 px-6 rounded-lg focus:outline-none focus:ring-2 focus:ring-white focus:ring-opacity-50">Start</button>
        </div>
    </div>


    <!-- Custom Message Box -->
    <div id="messageBox" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center">
        <div class="message-box rounded-lg p-8 text-center">
            <p id="messageText" class="text-2xl mb-6 text-white" style="text-shadow: 0 0 10px #00ffff;"></p>
            <button id="restartButton" class="restart-btn py-3 px-6 rounded-lg focus:outline-none focus:ring-2 focus:ring-white focus:ring-opacity-50">
                Play Again
            </button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('pongCanvas');
        const ctx = canvas.getContext('2d');

        // Lazy-load Tone.js only after a user gesture to avoid autoplay warnings
        let toneLoadPromise = null;
        function loadTone() {
            if (window.Tone) return Promise.resolve();
            if (toneLoadPromise) return toneLoadPromise;
            toneLoadPromise = new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = '/assets/pongo/vendor/tone/Tone.min.js';
                s.async = true;
                s.onload = () => resolve();
                s.onerror = (e) => reject(new Error('Failed to load Tone.js'));
                document.head.appendChild(s);
            });
            return toneLoadPromise;
        }

        const playerScoreElem = document.getElementById('player-score');
        const computerScoreElem = document.getElementById('computer-score');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');
        const muteButton = document.getElementById('muteButton');

        // --- Game Constants ---
        const PADDLE_WIDTH = 15;
        const PADDLE_HEIGHT = 100;
        const BALL_RADIUS = 10;
        const WINNING_SCORE = 5;
        const PADDLE_COLOR = '#00ffff';
        const BALL_COLOR = '#ffffff';
    // Tuning: how fast the ball accelerates after each paddle hit and max speed cap
    const SPEED_INCREMENT = 1.08; // was 1.05
    const MAX_SPEED_MULTIPLIER = 1.35; // was 1.2

// Speed multiplier controlled by UI slider (1.0 = default)
let speedMultiplier = 1.0;

// Hook up the slider after DOM elements exist; we'll query later during init
function setupSpeedSlider() {
    const slider = document.getElementById('speedSlider');
    const valueLabel = document.getElementById('speedValue');
    if (!slider || !valueLabel) return;

    // Initialize display and slider position
    slider.value = speedMultiplier;
    valueLabel.textContent = parseFloat(speedMultiplier).toFixed(2) + 'x';

    slider.addEventListener('input', (e) => {
        const v = parseFloat(e.target.value);
        speedMultiplier = v;
        valueLabel.textContent = v.toFixed(2) + 'x';
        // Apply multiplier to current ball velocities and maxSpeed
        if (ball) applySpeedMultiplierToBall(v);
    });

    // If a ball exists on setup, apply multiplier immediately
    if (ball) applySpeedMultiplierToBall(speedMultiplier);
}

function applySpeedMultiplierToBall(mult) {
    // Scale current speed magnitude while preserving direction
    const currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy) || 0;
    const baseSpeed = (canvas.width * 0.7) * mult;
    const desiredSpeed = Math.max(baseSpeed, currentSpeed * mult);
    const angle = Math.atan2(ball.vy, ball.vx);
    ball.vx = Math.cos(angle) * desiredSpeed;
    ball.vy = Math.sin(angle) * desiredSpeed;
    ball.maxSpeed = canvas.width * MAX_SPEED_MULTIPLIER * mult;
}


        // Keyboard control state
        const keys = { up:false, down:false, left:false, right:false };
        let keyboardSpeedFactor = 1.1; // fraction of canvas height per second

        let ball, player, computer, gameRunning;
        let particles = [];

        // --- Enhanced Audio System ---
        let audioSystem = null;
        let audioReady = false;
        let isMuted = false;
        let canPlayHitSound = true;
        let canPlayWallSound = true;

        class AudioSystem {
            constructor() {
                this.sounds = {};
                this.effects = {};
                this.masterVolume = new Tone.Volume(-6).toDestination(); // Slight reduction for headroom
                this.pulseInterval = null;
                this.setupEffects();
                this.setupSounds();
                this.setupDynamics();
            }

            setupDynamics() {
                // Add subtle ducking when scoring sounds play
                this.duckingGain = new Tone.Gain(1);
                this.effects.reverb.disconnect();
                this.effects.reverb.connect(this.duckingGain);
                this.duckingGain.connect(this.masterVolume);
            }

            setupEffects() {
                // Create shared effects for better cohesion
                this.effects.reverb = new Tone.Reverb({
                    roomSize: 0.3,
                    dampening: 3000,
                    wet: 0.15
                }).connect(this.masterVolume);

                this.effects.delay = new Tone.PingPongDelay({
                    delayTime: "8n",
                    feedback: 0.1,
                    wet: 0.05
                }).connect(this.effects.reverb);

                this.effects.filter = new Tone.Filter({
                    frequency: 8000,
                    type: "lowpass",
                    rolloff: -12
                }).connect(this.effects.delay);

                this.effects.compressor = new Tone.Compressor({
                    threshold: -18,
                    ratio: 4,
                    attack: 0.003,
                    release: 0.1
                }).connect(this.effects.filter);
            }

            setupSounds() {
                // Enhanced paddle hit sound with FM synthesis
                this.sounds.paddleHit = new Tone.FMSynth({
                    harmonicity: 1.5,
                    modulationIndex: 8,
                    oscillator: { type: "sine" },
                    modulation: { type: "square" },
                    envelope: {
                        attack: 0.002,
                        decay: 0.08,
                        sustain: 0.1,
                        release: 0.15
                    },
                    modulationEnvelope: {
                        attack: 0.001,
                        decay: 0.05,
                        sustain: 0.2,
                        release: 0.1
                    }
                }).connect(this.effects.compressor);

                // Enhanced wall bounce with membrane synthesis and pitch bend
                this.sounds.wallBounce = new Tone.MembraneSynth({
                    pitchDecay: 0.02,
                    octaves: 3,
                    oscillator: { type: "sine" },
                    envelope: {
                        attack: 0.001,
                        decay: 0.15,
                        sustain: 0.02,
                        release: 0.2
                    }
                }).connect(this.effects.compressor);

                // Player score - triumphant arpeggio
                this.sounds.playerScore = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "sawtooth" },
                    envelope: {
                        attack: 0.01,
                        decay: 0.3,
                        sustain: 0.2,
                        release: 0.8
                    }
                }).connect(this.effects.reverb);

                // Computer score - darker chord
                this.sounds.computerScore = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "square" },
                    envelope: {
                        attack: 0.02,
                        decay: 0.4,
                        sustain: 0.15,
                        release: 0.6
                    }
                }).connect(this.effects.reverb);

                // Ambient background pad (subtle)
                this.sounds.ambient = new Tone.Synth({
                    oscillator: { type: "sine" },
                    envelope: {
                        attack: 2,
                        decay: 1,
                        sustain: 0.8,
                        release: 3
                    }
                }).connect(new Tone.Volume(-24).connect(this.effects.reverb));

                // Additional ambient layer with subtle movement
                this.sounds.ambientHigh = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: {
                        attack: 3,
                        decay: 2,
                        sustain: 0.6,
                        release: 4
                    }
                }).connect(new Tone.Volume(-28).connect(this.effects.reverb));

                // Subtle rhythmic pulse
                this.sounds.pulse = new Tone.Synth({
                    oscillator: { type: "sine" },
                    envelope: {
                        attack: 0.1,
                        decay: 0.3,
                        sustain: 0.1,
                        release: 0.5
                    }
                }).connect(new Tone.Volume(-30).connect(this.effects.reverb));

                // Game state transition sound
                this.sounds.transition = new Tone.Synth({
                    oscillator: { type: "sawtooth" },
                    envelope: {
                        attack: 0.05,
                        decay: 0.2,
                        sustain: 0.3,
                        release: 0.8
                    }
                }).connect(this.effects.reverb);

                // UI interaction sounds
                this.sounds.buttonClick = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: {
                        attack: 0.01,
                        decay: 0.1,
                        sustain: 0.1,
                        release: 0.2
                    }
                }).connect(new Tone.Volume(-12).connect(this.effects.compressor));

                this.sounds.buttonHover = new Tone.Synth({
                    oscillator: { type: "sine" },
                    envelope: {
                        attack: 0.005,
                        decay: 0.05,
                        sustain: 0.05,
                        release: 0.1
                    }
                }).connect(new Tone.Volume(-18).connect(this.effects.compressor));
            }

            playPaddleHit(ballSpeed, hitPosition) {
                if (!canPlayHitSound) return;

                // Dynamic pitch based on ball speed and hit position
                const baseNote = 60; // C4
                const speedFactor = Math.min(ballSpeed / 10, 2); // Normalize speed
                const positionFactor = (hitPosition + 1) * 0.5; // Convert -1 to 1 range to 0 to 1
                const pitch = baseNote + (speedFactor * 12) + (positionFactor * 7);

                // Add slight random variation for more organic feel
                const variation = (Math.random() - 0.5) * 2; // Â±1 semitone
                const finalPitch = pitch + variation;

                const note = Tone.Frequency(finalPitch, "midi").toNote();
                const duration = Math.max(0.05, 0.15 - speedFactor * 0.05);

                // Adjust FM synthesis parameters based on hit intensity
                this.sounds.paddleHit.harmonicity.value = 1.5 + (speedFactor * 0.5);
                this.sounds.paddleHit.modulationIndex.value = 8 + (speedFactor * 4);

                this.sounds.paddleHit.triggerAttackRelease(note, duration, Tone.now() + 0.01);

                // Visual feedback - brief screen flash
                this.createAudioVisualFeedback('paddle', speedFactor);

                canPlayHitSound = false;
                setTimeout(() => { canPlayHitSound = true; }, 80);
            }

            playWallBounce(ballSpeed, yPosition, canvasHeight) {
                if (!canPlayWallSound) return;

                // Dynamic pitch based on ball speed and wall position
                const baseNote = 36; // C2
                const speedFactor = Math.min(ballSpeed / 10, 2);
                const positionFactor = yPosition / canvasHeight; // 0 to 1 from top to bottom

                // Higher pitch for top wall, lower for bottom
                const positionPitch = positionFactor < 0.5 ? 6 : -3;
                const pitch = baseNote + (speedFactor * 8) + positionPitch;

                // Add impact variation
                const impactVariation = (Math.random() - 0.5) * 3;
                const finalPitch = pitch + impactVariation;

                const note = Tone.Frequency(finalPitch, "midi").toNote();

                // Adjust membrane parameters for more impact
                this.sounds.wallBounce.pitchDecay = 0.02 + (speedFactor * 0.01);
                this.sounds.wallBounce.octaves = 3 + (speedFactor * 1);

                // Vary duration based on impact force
                // Use musical notation strings directly; avoid Math.max on strings
                const duration = speedFactor > 1 ? "8n" : "16n";

                this.sounds.wallBounce.triggerAttackRelease(note, duration, Tone.now() + 0.01);

                // Visual feedback - wall flash
                this.createAudioVisualFeedback('wall', speedFactor, positionFactor);

                canPlayWallSound = false;
                setTimeout(() => { canPlayWallSound = true; }, 100);
            }

            playPlayerScore() {
                // Duck ambient sounds slightly
                this.duckAmbient(0.7, 2);

                // Visual feedback for player scoring
                this.createAudioVisualFeedback('score', 0.8);

                // Triumphant major arpeggio with ascending melody
                const baseNote = 72; // C5
                const arpeggio = [0, 4, 7, 12, 16]; // C major arpeggio going up two octaves

                // Play the main arpeggio
                arpeggio.forEach((interval, index) => {
                    const note = Tone.Frequency(baseNote + interval, "midi").toNote();
                    this.sounds.playerScore.triggerAttackRelease(
                        note,
                        "8n",
                        Tone.now() + 0.02 + (index * 0.08)
                    );
                });

                // Add a celebratory chord at the end
                const finalChord = [0, 4, 7].map(interval =>
                    Tone.Frequency(baseNote + 12 + interval, "midi").toNote()
                );
                this.sounds.playerScore.triggerAttackRelease(
                    finalChord,
                    "2n",
                    Tone.now() + 0.5
                );
            }

            playComputerScore() {
                // Duck ambient sounds slightly
                this.duckAmbient(0.6, 2.5);

                // Visual feedback for computer scoring (more subtle)
                this.createAudioVisualFeedback('score', 0.5);

                // Darker, more ominous sound with descending pattern
                const baseNote = 55; // G3
                const descending = [12, 8, 5, 3, 0]; // Descending minor pattern

                // Play descending notes
                descending.forEach((interval, index) => {
                    const note = Tone.Frequency(baseNote + interval, "midi").toNote();
                    this.sounds.computerScore.triggerAttackRelease(
                        note,
                        "8n",
                        Tone.now() + 0.02 + (index * 0.12)
                    );
                });

                // Add a final minor chord
                const finalChord = [0, 3, 7].map(interval =>
                    Tone.Frequency(baseNote + interval, "midi").toNote()
                );
                this.sounds.computerScore.triggerAttackRelease(
                    finalChord,
                    "2n",
                    Tone.now() + 0.7
                );
            }

            duckAmbient(level, duration) {
                // Temporarily reduce ambient volume for scoring sounds
                this.duckingGain.gain.rampTo(level, 0.1);
                setTimeout(() => {
                    this.duckingGain.gain.rampTo(1, 0.5);
                }, duration * 1000);
            }

            startAmbient() {
                // Subtle ambient drone with multiple layers
                this.sounds.ambient.triggerAttack("C2", Tone.now());
                this.sounds.ambientHigh.triggerAttack("G3", Tone.now() + 1);

                // Start subtle pulse
                this.startPulse();
            }

            stopAmbient() {
                this.sounds.ambient.triggerRelease(Tone.now() + 1);
                this.sounds.ambientHigh.triggerRelease(Tone.now() + 1.5);
                this.stopPulse();
            }

            startPulse() {
                if (this.pulseInterval) return;

                const playPulse = () => {
                    if (!isMuted && gameRunning) {
                        this.sounds.pulse.triggerAttackRelease("C1", "32n", Tone.now());
                    }
                };

                // Very subtle pulse every 4 seconds
                this.pulseInterval = setInterval(playPulse, 4000);
            }

            stopPulse() {
                if (this.pulseInterval) {
                    clearInterval(this.pulseInterval);
                    this.pulseInterval = null;
                }
            }

            playGameStart() {
                // Subtle upward sweep when game starts
                this.sounds.transition.triggerAttackRelease("C3", "2n", Tone.now());
            }

            playGameEnd() {
                // Downward sweep when game ends
                this.sounds.transition.triggerAttackRelease("C2", "1n", Tone.now());
            }

            playButtonClick() {
                // Subtle click sound for buttons
                this.sounds.buttonClick.triggerAttackRelease("C5", "16n", Tone.now());
            }

            playButtonHover() {
                // Very subtle hover sound
                this.sounds.buttonHover.triggerAttackRelease("G5", "32n", Tone.now());
            }

            createAudioVisualFeedback(type, intensity, position = 0.5) {
                // Create subtle visual feedback that responds to audio
                const canvas = document.getElementById('pongCanvas');
                if (!canvas) return;

                switch (type) {
                    case 'paddle':
                        // Brief screen edge glow
                        this.flashScreenEdge(intensity * 0.3, 100);
                        break;
                    case 'wall':
                        // Flash the wall area
                        this.flashWallArea(position, intensity * 0.4, 150);
                        break;
                    case 'score':
                        // Full screen subtle flash
                        this.flashScreen(intensity * 0.2, 300);
                        break;
                }
            }

            flashScreenEdge(opacity, duration) {
                const canvas = document.getElementById('pongCanvas');
                const originalBoxShadow = canvas.style.boxShadow;
                canvas.style.boxShadow = `0 0 20px rgba(0, 255, 255, ${opacity})`;
                setTimeout(() => {
                    canvas.style.boxShadow = originalBoxShadow;
                }, duration);
            }

            flashWallArea(position, opacity, duration) {
                // Create a temporary overlay for wall flash
                const canvas = document.getElementById('pongCanvas');
                const overlay = document.createElement('div');
                overlay.style.position = 'absolute';
                overlay.style.top = position < 0.5 ? '0' : 'auto';
                overlay.style.bottom = position >= 0.5 ? '0' : 'auto';
                overlay.style.left = '0';
                overlay.style.right = '0';
                overlay.style.height = '5px';
                overlay.style.backgroundColor = `rgba(255, 255, 255, ${opacity})`;
                overlay.style.pointerEvents = 'none';
                overlay.style.zIndex = '10';

                canvas.parentElement.appendChild(overlay);
                setTimeout(() => {
                    if (overlay.parentElement) {
                        overlay.parentElement.removeChild(overlay);
                    }
                }, duration);
            }

            flashScreen(opacity, duration) {
                const body = document.body;
                const originalFilter = body.style.filter;
                body.style.filter = `brightness(${1 + opacity})`;
                setTimeout(() => {
                    body.style.filter = originalFilter;
                }, duration);
            }

            dispose() {
                // Clean up pulse interval
                this.stopPulse();

                // Dispose of all audio nodes
                Object.values(this.sounds).forEach(sound => {
                    if (sound && typeof sound.dispose === 'function') {
                        sound.dispose();
                    }
                });
                Object.values(this.effects).forEach(effect => {
                    if (effect && typeof effect.dispose === 'function') {
                        effect.dispose();
                    }
                });

                if (this.masterVolume && typeof this.masterVolume.dispose === 'function') {
                    this.masterVolume.dispose();
                }
                if (this.duckingGain && typeof this.duckingGain.dispose === 'function') {
                    this.duckingGain.dispose();
                }
            }
        }

        function setupAudio() {
            if (!window.Tone) return;
            if (audioSystem) return;

            try {
                audioSystem = new AudioSystem();
                console.log("Enhanced audio system initialized");
            } catch (error) {
                console.warn("Failed to initialize audio system:", error);
            }
        }

        // --- Layout helpers ---
        function getCanvasSize() {
            const aspectRatio = 16 / 9;
            const isDesktop = window.innerWidth >= 1024;
            const widthPct = isDesktop ? 0.8 : 0.95; // desktop a bit smaller
            const maxW = isDesktop ? 1000 : 1200;

            // Start from width constraint
            let width = Math.min(window.innerWidth * widthPct, maxW);
            let height = width / aspectRatio;

            // Then constrain by the vertical space available below the header/score
            const container = canvas.parentElement || document.body;
            const topOffset = container.getBoundingClientRect().top;
            const verticalPadding = 16; // a little breathing room
            const availableH = Math.max(200, window.innerHeight - topOffset - verticalPadding);

            if (height > availableH) {
                height = availableH;
                width = height * aspectRatio;
            }

            // Just in case width now exceeds viewport * widthPct after height clamp
            const maxWidthByViewport = window.innerWidth * widthPct;
            if (width > maxWidthByViewport) {
                width = maxWidthByViewport;
                height = width / aspectRatio;
            }

            return { width: Math.round(width), height: Math.round(height) };
        }

        // --- Game Objects Initialization ---
        function initGameObjects() {
            const size = getCanvasSize();
            canvas.width = size.width;
            canvas.height = size.height;

            // Speeds are in pixels per second (frame-rate independent)
            const BASE_SPEED = canvas.width * 0.7 * speedMultiplier; // crosses ~1.4s
            const angle = Math.PI / 4; // 45 degrees
            const dirX = Math.random() > 0.5 ? 1 : -1;
            const dirY = Math.random() > 0.5 ? 1 : -1;

            ball = {
                x: canvas.width / 2,
                y: canvas.height / 2,
                radius: BALL_RADIUS,
                vx: dirX * BASE_SPEED * Math.cos(angle),
                vy: dirY * BASE_SPEED * Math.sin(angle),
                maxSpeed: canvas.width * MAX_SPEED_MULTIPLIER * speedMultiplier
            };
            player = { x: 10, y: canvas.height / 2 - PADDLE_HEIGHT / 2, width: PADDLE_WIDTH, height: PADDLE_HEIGHT, score: 0 };
            computer = { x: canvas.width - 10 - PADDLE_WIDTH, y: canvas.height / 2 - PADDLE_HEIGHT / 2, width: PADDLE_WIDTH, height: PADDLE_HEIGHT, score: 0, maxSpeed: canvas.height * 0.9 };

            gameRunning = true;

            // Start ambient audio when game begins
            if (audioReady && audioSystem && !isMuted) {
                audioSystem.playGameStart();
                setTimeout(() => {
                    if (gameRunning && !isMuted) {
                        audioSystem.startAmbient();
                    }
                }, 500);
            }
            // Wire up speed slider UI (idempotent)
            setupSpeedSlider();
        }

        // --- Drawing Functions ---
        function drawRect(x, y, w, h, color) {
            ctx.fillStyle = color;
            ctx.shadowBlur = 20;
            ctx.shadowColor = color;
            ctx.fillRect(x, y, w, h);
            ctx.shadowBlur = 0;
        }

        function drawCircle(x, y, r, color) {
            ctx.fillStyle = color;
            ctx.shadowBlur = 20;
            ctx.shadowColor = color;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2, false);
            ctx.closePath();
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawNet() {
            for (let i = 0; i < canvas.height; i += 30) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fillRect(canvas.width / 2 - 1, i, 2, 15);
            }
        }

        // --- Particle System ---
        function createParticles(x, y, color) {
            for (let i = 0; i < 15; i++) {
                particles.push({ x, y, radius: Math.random() * 3 + 1, color, speedX: (Math.random() - 0.5) * 5, speedY: (Math.random() - 0.5) * 5, life: 1 });
            }
        }

        function updateAndDrawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.speedX;
                p.y += p.speedY;
                p.life -= 0.05;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                } else {
                    ctx.save();
                    ctx.globalAlpha = p.life;
                    drawCircle(p.x, p.y, p.radius, p.color);
                    ctx.restore();
                }
            }
        }

        // --- Game Logic ---
        function resetBall() {
                    const BASE_SPEED = canvas.width * 0.7 * speedMultiplier;
            const angle = Math.PI / 4;
            const dirX = Math.random() > 0.5 ? 1 : -1;
            const dirY = Math.random() > 0.5 ? 1 : -1;
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            ball.vx = dirX * BASE_SPEED * Math.cos(angle);
            ball.vy = dirY * BASE_SPEED * Math.sin(angle);
                    ball.maxSpeed = canvas.width * MAX_SPEED_MULTIPLIER * speedMultiplier;
        }

        function update(dt) {
            if (!gameRunning) return;

            // Move ball
            ball.x += ball.vx * dt;
            ball.y += ball.vy * dt;

            // Move computer paddle
            const target = ball.y - (computer.height / 2);
            const diff = target - computer.y;
            const step = computer.maxSpeed * dt;
            if (Math.abs(diff) <= step) {
                computer.y = target;
            } else {


                computer.y += Math.sign(diff) * step;
            }
            if (computer.y < 0) computer.y = 0;
            if (computer.y > canvas.height - computer.height) computer.y = canvas.height - computer.height;


            // Player keyboard control (Arrow/W/S)
            {
                const speed = canvas.height * keyboardSpeedFactor;
                if (keys.up) player.y -= speed * dt;
                if (keys.down) player.y += speed * dt;
                if (player.y < 0) player.y = 0;
                if (player.y > canvas.height - player.height) player.y = canvas.height - player.height;
            }

            // Ball collision with top/bottom walls
            if ((ball.y + ball.radius > canvas.height && ball.vy > 0) || (ball.y - ball.radius < 0 && ball.vy < 0)) {
                if (ball.y + ball.radius > canvas.height) ball.y = canvas.height - ball.radius;
                else ball.y = ball.radius;

                ball.vy *= -1;



                if (audioReady && window.Tone && Tone.context.state === 'running' && audioSystem) {
                    const ballSpeed = Math.sqrt(ball.vx**2 + ball.vy**2);
                    audioSystem.playWallBounce(ballSpeed, ball.y, canvas.height);
                }
                createParticles(ball.x, ball.y, 'rgba(255, 255, 255, 0.5)');
            }

            // Ball collision with paddles
            let paddle = (ball.x < canvas.width / 2) ? player : computer;
            if (collision(ball, paddle)) {
                let collidePoint = (ball.y - (paddle.y + paddle.height / 2)) / (paddle.height / 2);

                if (audioReady && window.Tone && Tone.context.state === 'running' && audioSystem) {
                    const ballSpeed = Math.sqrt(ball.vx**2 + ball.vy**2);
                    audioSystem.playPaddleHit(ballSpeed, collidePoint);
                }

                createParticles(ball.x, ball.y, PADDLE_COLOR);

                let angleRad = (Math.PI / 4) * collidePoint;
                let direction = (ball.x < canvas.width / 2) ? 1 : -1;

                let currentSpeed = Math.sqrt(ball.vx**2 + ball.vy**2);
                let newSpeed = Math.min(ball.maxSpeed, currentSpeed * SPEED_INCREMENT);

                ball.vx = direction * newSpeed * Math.cos(angleRad);
                ball.vy = newSpeed * Math.sin(angleRad);

                if(direction === 1) ball.x = player.x + player.width + ball.radius;
                else ball.x = computer.x - ball.radius;
            }

            // Scoring
            if (ball.x - ball.radius < 0) {
                if (audioReady && window.Tone && Tone.context.state === 'running' && audioSystem) {
                    audioSystem.playComputerScore();
                }
                computer.score++;
                updateScores();
                resetBall();
            } else if (ball.x + ball.radius > canvas.width) {
                if (audioReady && window.Tone && Tone.context.state === 'running' && audioSystem) {
                    audioSystem.playPlayerScore();
                }
                player.score++;
                updateScores();
                resetBall();
            }

            checkWinner();
        }

        function collision(b, p) {
            return b.x + b.radius > p.x && b.x - b.radius < p.x + p.width &&
                   b.y + b.radius > p.y && b.y - b.radius < p.y + p.height;
        }

        function updateScores() {
            playerScoreElem.textContent = player.score;
            computerScoreElem.textContent = computer.score;
        }

        function checkWinner() {
            if (player.score >= WINNING_SCORE) endGame("You Win!");
            else if (computer.score >= WINNING_SCORE) endGame("Computer Wins!");
        }

        function endGame(message) {
            gameRunning = false;
            messageText.textContent = message;
            messageBox.classList.remove('hidden');

            // Stop ambient audio when game ends
            if (audioSystem) {
                audioSystem.playGameEnd();
                audioSystem.stopAmbient();
            }
        }

    function render() {
            ctx.fillStyle = 'rgba(15, 12, 41, 0.25)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawNet();
            drawRect(player.x, player.y, player.width, player.height, PADDLE_COLOR);
            drawRect(computer.x, computer.y, computer.width, computer.height, PADDLE_COLOR);
            drawCircle(ball.x, ball.y, ball.radius, BALL_COLOR);
            updateAndDrawParticles();
        }

        let lastTime = performance.now();
        function gameLoop(now) {
            if (now === undefined) now = performance.now();
            const dt = Math.min((now - lastTime) / 1000, 0.033); // cap to avoid huge jumps
            lastTime = now;
            if (gameRunning) update(dt);
            render();
            requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners & Game Start ---
        async function startAudioContext() {
            try {
                if (!window.Tone) {
                    console.warn('Tone.js not loaded; continuing without audio.');
                    audioReady = false;
                    // Disable mute button when audio is unavailable
                    muteButton.setAttribute('aria-disabled', 'true');
                    muteButton.style.opacity = '0.5';
                    return;
                }
                if (Tone.context.state !== 'running') {
                    await Tone.start();
                    console.log("Audio context started.");
                }
                setupAudio();
                audioReady = (Tone.context.state === 'running');
            } catch (e) {
                console.warn('Failed to start audio context', e);
            }
        }

        // Start overlay interactions
        const startOverlay = document.getElementById('startOverlay');
        const startButton = document.getElementById('startButton');
        async function handleStart() {
            try {
                await loadTone();
            } catch (e) {
                console.warn('Tone.js failed to load; continuing without audio.', e);
            }
            await startAudioContext();
            startOverlay.classList.add('hidden');
        }
        startButton.addEventListener('click', () => {
            if (audioSystem) audioSystem.playButtonClick();
            handleStart();
        });
        startOverlay.addEventListener('click', (e) => {
            // allow clicking outside button to start as well
            if (e.target === startOverlay) {
                if (audioSystem) audioSystem.playButtonClick();
                handleStart();
            }


        });


        function movePlayer(event) {
            let rect = canvas.getBoundingClientRect();
            let clientY = event.touches ? event.touches[0].clientY : event.clientY;
            player.y = clientY - rect.top - player.height / 2;
            if (player.y < 0) player.y = 0;
            if (player.y > canvas.height - player.height) player.y = canvas.height - player.height;
        }

        canvas.addEventListener('mousemove', movePlayer);
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            movePlayer(e);
        }, {passive: false});

        // Keyboard listeners (top-level)
        window.addEventListener('keydown', (e) => {
            const k = e.key;
            if (k === 'ArrowUp' || k === 'w' || k === 'W') { keys.up = true; e.preventDefault(); }
            if (k === 'ArrowDown' || k === 's' || k === 'S') { keys.down = true; e.preventDefault(); }
            if (k === 'ArrowLeft' || k === 'a' || k === 'A') { keys.left = true; }
            if (k === 'ArrowRight' || k === 'd' || k === 'D') { keys.right = true; }
        });
        window.addEventListener('keyup', (e) => {
            const k = e.key;
            if (k === 'ArrowUp' || k === 'w' || k === 'W') keys.up = false;
            if (k === 'ArrowDown' || k === 's' || k === 'S') keys.down = false;
            if (k === 'ArrowLeft' || k === 'a' || k === 'A') keys.left = false;
            if (k === 'ArrowRight' || k === 'd' || k === 'D') keys.right = false;
        });



        muteButton.addEventListener('click', () => {
            if (!window.Tone) return; // no audio available
            if (!audioReady) startAudioContext(); // Ensure audio is ready after user gesture

            // Play click sound before muting (if not already muted)
            if (audioSystem && !isMuted) audioSystem.playButtonClick();

            isMuted = !isMuted;
            Tone.Destination.mute = isMuted;
            muteButton.textContent = isMuted ? 'ðŸ”‡' : 'ðŸ”Š';

            // Handle ambient audio based on mute state
            if (audioSystem && gameRunning) {
                if (isMuted) {
                    audioSystem.stopAmbient();
                } else {
                    audioSystem.startAmbient();
                }
            }
        });

        restartButton.addEventListener('click', () => {
            if (audioSystem && !isMuted) audioSystem.playButtonClick();
            messageBox.classList.add('hidden');
            initGameObjects();
            updateScores();
        });

        // Preserve state on resize and keep canvas fully on-screen
        let resizeRaf = null;
        function resizeCanvasPreserveState() {
            const oldW = canvas.width;
            const oldH = canvas.height;
            const { width: newW, height: newH } = getCanvasSize();
            if (oldW === newW && oldH === newH) return;

            const scaleX = newW / oldW;
            const scaleY = newH / oldH;

            canvas.width = newW;
            canvas.height = newH;

            // Scale positions
            if (ball) {
                ball.x *= scaleX;
                ball.y *= scaleY;
                ball.vx *= scaleX; // keep px/s scaled with canvas size
                ball.vy *= scaleY;
                ball.maxSpeed = canvas.width * MAX_SPEED_MULTIPLIER * speedMultiplier;
            }
            if (player) {
                player.y *= scaleY;
                if (player.y < 0) player.y = 0;
                if (player.y > canvas.height - player.height) player.y = canvas.height - player.height;
                player.x = 10;
            }
            if (computer) {
                computer.y *= scaleY;
                if (computer.y < 0) computer.y = 0;
                if (computer.y > canvas.height - computer.height) computer.y = canvas.height - computer.height;
                computer.x = canvas.width - 10 - computer.width;
                computer.maxSpeed = canvas.height * 0.9;
            }
        }

        function handleResize() {
            if (resizeRaf) cancelAnimationFrame(resizeRaf);
            resizeRaf = requestAnimationFrame(resizeCanvasPreserveState);
        }
        window.addEventListener('resize', handleResize);

        // Clean up audio system when page is unloaded
        window.addEventListener('beforeunload', () => {
            if (audioSystem) {
                audioSystem.dispose();
            }
        });

        initGameObjects();
        gameLoop();
    </script>
</body>
</html>



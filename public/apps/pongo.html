<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pongo Game</title>
    <link rel="stylesheet" href="/assets/pongo/dist/styles.css">
    <link rel="icon" type="image/svg+xml" href="/assets/pongo/favicon.svg">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="/socket.io/socket.io.js"></script>

    <script src="/assets/pongo/dist/pongo-core.js"></script>

    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background: #0f0c29;
            background: -webkit-linear-gradient(to right, #24243e, #302b63, #0f0c29);
            background: linear-gradient(to right, #24243e, #302b63, #0f0c29);
            color: #ffffff;
            overflow: hidden; /* Prevent scrolling */
        }
        canvas {
            background-color: rgba(0, 0, 0, 0.5);
            display: block;
            border: 2px solid #00ffff;
            box-shadow: 0 0 25px #00ffff, inset 0 0 15px rgba(0, 255, 255, 0.5);
            border-radius: 10px;
            cursor: none; /* Hide cursor over canvas */
        }
        .title, .score-label {
             color: #00ffff;
             text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
        }
        .score {
            color: #ffffff;
            text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff;
        }
        .message-box {
            background-color: rgba(0, 0, 0, 0.6);
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
            backdrop-filter: blur(5px);
        }
        .restart-btn {
            background-color: #00ffff;
            color: #0f0c29;
            text-shadow: none;
            box-shadow: 0 0 15px #00ffff;
            transition: all 0.3s ease;
        }
        .restart-btn:hover {
            background-color: #ffffff;
            color: #000;
            box-shadow: 0 0 25px #ffffff;
        }
        #muteButton {
            text-shadow: 0 0 10px #00ffff;
        }
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 255, 255, 0.9);
            color: #0f0c29;
            padding: 12px 24px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            z-index: 1000;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s ease;
        }
        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }
    </style>
</head>
<body class="flex flex-col items-center justify-start sm:justify-center min-h-screen p-2 sm:p-4">
    <script>
      // Parse clean URL: /:app/:roomId ‚Üí expose for multiplayer clients
      (function(){
        try {
          const parts = (location.pathname || '/').split('/').filter(Boolean);
          window.APP_SLUG = parts[0] || 'pongo';
          window.ROOM_ID = parts[1] || 'default'; // Always use 'default' room if no room specified
          if (window.ROOM_ID) console.log('App/Room:', window.APP_SLUG, window.ROOM_ID);
        } catch {}
      })();
    </script>

    <script>
      // Multiplayer wiring using server /game - always enabled now with default room
      (function(){
        // Determine initial mode from query (?mode=ai or ?ai=1) else default Online
        (function(){
          const q = new URLSearchParams(location.search);
          const mode = (q.get('mode')||'').toLowerCase();
          const ai = q.get('ai');
          const aiRequested = (mode === 'ai') || (ai === '1') || (ai === 'true');
          window.USE_MULTIPLAYER = !aiRequested;
        })();
        // Simple debug toggle: ?debug=1 or localStorage.DEBUG_MP = '1'
        const urlDebug = /[?&]debug=1/.test(location.search);
        const isLocalDev = ['localhost', '127.0.0.1'].includes(location.hostname);
        window.DEBUG_MP = urlDebug || (localStorage.getItem('DEBUG_MP') === '1') || isLocalDev;
        if (window.DEBUG_MP) console.log('[mp] debug enabled');
      })();

        // Forward important client-side events to the server log (saved to /logs)
        window.clientLog = function(event, data){
          try{
            if (window.DEBUG_MP) console.log('[client]', event, data||{});
            if (window.sock && typeof window.sock.emit==='function'){
              window.sock.emit('client:log', { event, data });
            }
          }catch(e){}
        };


      // Multiplayer logic now in global scope to be accessible
      let sock = null, side = null;
      let upTimer=null, downTimer=null;
      let mySeq = 0;
      const pending = []; // {seq, direction}
      let TICK_RATE = 30; // Hz (will be replaced by /game/config)
      let PADDLE_SPEED = 0.5; // units/sec
      let DT = 1 / TICK_RATE;
      window.PADDLE_HEIGHT_NORM = 0.2;

      // Load server config to avoid drift
      try {
        fetch('/game/config').then(r=>r.json()).then(cfg=>{
          if (cfg && typeof cfg.TICK_RATE==='number') TICK_RATE = cfg.TICK_RATE;
          if (cfg && typeof cfg.PADDLE_SPEED==='number') PADDLE_SPEED = cfg.PADDLE_SPEED;
          if (cfg && typeof cfg.PADDLE_HEIGHT==='number') window.PADDLE_HEIGHT_NORM = cfg.PADDLE_HEIGHT;
          DT = 1 / TICK_RATE;
          if (window.DEBUG_MP) console.log('[mp] config', {TICK_RATE, PADDLE_SPEED, PADDLE_HEIGHT_NORM: window.PADDLE_HEIGHT_NORM});
        }).catch((e)=>{ if (window.DEBUG_MP) console.warn('[mp] config fetch failed', e); });
      } catch (e) { if (window.DEBUG_MP) console.warn('[mp] config error', e); }

      function sendMove(direction){
        if (!sock) return;
        const seq = ++mySeq;
        sock.emit('input', { action:'move', direction, seq });
        pending.push({ seq, direction });
      }
      function startRepeat(dir){
        if ((dir==='up' && upTimer) || (dir==='down' && downTimer)) return;
        const send = ()=> sendMove(dir);
        if (dir==='up') { upTimer = setInterval(send, 60); send(); }
        if (dir==='down') { downTimer = setInterval(send, 60); send(); }
      }
      function stopRepeat(dir){
        if (dir==='up' && upTimer){ clearInterval(upTimer); upTimer=null; }
        if (dir==='down' && downTimer){ clearInterval(downTimer); downTimer=null; }
      }
      function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
      function normToPxY(n){
        const h = (window.canvas && canvas.height) || window.innerHeight;
        return clamp(n,0,1) * (h - (window.PADDLE_HEIGHT||100));
      }
      function normToPxX(n){
        const w = (window.canvas && canvas.width) || window.innerWidth;
        return clamp(n,0,1) * w;
      }
      function normToPxYFull(n){
        const h = (window.canvas && canvas.height) || window.innerHeight;
        const v = Math.max(0, Math.min(1, n));
        return v * h;
      }

      function centerNormToPxTop(n, rectH){
        const h = (window.canvas && canvas.height) || window.innerHeight;
        const v = Math.max(0, Math.min(1, n));
        const center = v * h;
        const top = center - rectH/2;
        return Math.max(0, Math.min(h - rectH, top));
      }

      function applyPrediction(baseY){
        let y = baseY;
        for (const inp of pending){
          const dy = inp.direction === 'up' ? -PADDLE_SPEED * DT : PADDLE_SPEED * DT;
          y = clamp(y + dy, 0 + (window.PADDLE_HEIGHT_NORM||0.2)/2, 1 - (window.PADDLE_HEIGHT_NORM||0.2)/2);
        }
        return y;
      }
      // Snapshot buffer for interpolation
      window.STATE_BUFFER = window.STATE_BUFFER || [];
      window.RENDER_BUFFER_MS = window.RENDER_BUFFER_MS || 100;
      let __lastRoundState = null;
      let __lastAckSeqLog = -1, __lastPendingLog = -1;
      function applyState(s){
        try{
          // Reconciliation: drop acked inputs using server's lastSeq
          if (side && s.lastSeq){
            const ackSeq = s.lastSeq[side];
            for (let i = pending.length - 1; i >= 0; i--) {
              if (pending[i].seq <= ackSeq) pending.splice(i,1);
            }
            if (window.DEBUG_MP) {
              const pLen = pending.length;
              const shouldLog = (ackSeq > 0 && ackSeq !== __lastAckSeqLog) || (pLen > 0 && pLen !== __lastPendingLog);
              if (shouldLog) {
                console.log('[mp] state ack', { side, ackSeq, pending: pLen });
                __lastAckSeqLog = ackSeq;
                __lastPendingLog = pLen;
              }
            }
          }
          const snap = {
            _at: performance.now(), // local receipt time
            t: s.t,
            paddles: { left: Number(s.paddles.left)||0.5, right: Number(s.paddles.right)||0.5 },
            ball: { x: Number(s.ball.x)||0.5, y: Number(s.ball.y)||0.5 },
            scores: s.scores || { left: 0, right: 0 },
            // include server round state so client can detect whether the server has started
            roundState: s.roundState || 'waiting',
            roundTimer: Number(s.roundTimer) || 0
          };
          const buf = window.STATE_BUFFER;
          buf.push(snap);
          if (buf.length > 60) buf.splice(0, buf.length - 60);
          if (__lastRoundState !== snap.roundState) {
            if (window.DEBUG_MP) console.log('[mp] roundState', __lastRoundState, '->', snap.roundState, 'ball', snap.ball, 'paddles', snap.paddles);
            if (window.clientLog) window.clientLog('roundState', { prev: __lastRoundState, next: snap.roundState, ball: snap.ball, paddles: snap.paddles, t: snap.t });
            __lastRoundState = snap.roundState;
          }
          // Multiplayer waiting UI
          if (window.USE_MULTIPLAYER) {
            const box = document.getElementById('messageBox');
            const text = document.getElementById('messageText');
            const btn = document.getElementById('restartButton');
            if (snap.roundState === 'waiting') {
              if (box && text && btn) { box.classList.remove('hidden'); text.textContent = `Waiting for another player to join${window.ROOM_ID?` in room ‚Äú${window.ROOM_ID}‚Äù`:''}‚Ä¶`; btn.classList.add('hidden'); }
            } else {
              if (box && text && btn) { text.textContent = ''; btn.classList.remove('hidden'); box.classList.add('hidden'); }
            }
          }
          // Update scores immediately
          if (s.scores && window.updateScores){
            if (typeof player==='object') player.score = s.scores.left|0;
            if (typeof computer==='object') computer.score = s.scores.right|0;
            updateScores();
          }
        }catch(e){ if (window.DEBUG_MP) console.warn('[mp] applyState error', e); }
      }
      function stepMultiplayer(now){
        const buf = window.STATE_BUFFER;
        if (!buf || buf.length === 0) return;
        const target = (typeof now === 'number' ? now : performance.now()) - window.RENDER_BUFFER_MS;
        // Find bracketing snapshots
        let a = buf[0], b = buf[buf.length-1];
        for (let i=0;i<buf.length-1;i++){
          if (buf[i]._at <= target && target <= buf[i+1]._at){ a = buf[i]; b = buf[i+1]; break; }
        }
        const span = Math.max(1, b._at - a._at);
        const t = Math.max(0, Math.min(1, (target - a._at)/span));
        if (window.DEBUG_MP && (Math.random() < 0.02)) {
          console.log('[mp] interp', { buf: buf.length, target: Math.round(target)%10000, aT: Math.round(a._at)%10000, bT: Math.round(b._at)%10000, t: Number(t.toFixed(2)), aRS: a.roundState, bRS: b.roundState });
        }
        const lerp = (x0,x1)=> x0 + (x1-x0)*t;
        // Base interpolated values from server
        const leftY = lerp(a.paddles.left, b.paddles.left);
        const rightY = lerp(a.paddles.right, b.paddles.right);
        const ballX = lerp(a.ball.x, b.ball.x);
        const ballY = lerp(a.ball.y, b.ball.y);
        // Apply client prediction to own paddle
        let selfY = side==='left' ? leftY : rightY;
        selfY = side ? applyPrediction(selfY) : selfY;
        // Write to scene
        // Smooth the local paddle to hide reconciliation snaps
        const localTarget = centerNormToPxTop(selfY, PADDLE_HEIGHT);
        const otherTargetLeft  = centerNormToPxTop(leftY,  PADDLE_HEIGHT);
        const otherTargetRight = centerNormToPxTop(rightY, PADDLE_HEIGHT);
        window.__MP_LAST_TS = (typeof window.__MP_LAST_TS==='number') ? window.__MP_LAST_TS : now;
        const dtMs = Math.max(0, Math.min(50, (typeof now==='number'? now : performance.now()) - window.__MP_LAST_TS));
        window.__MP_LAST_TS = (typeof now==='number'? now : performance.now());
        const SMOOTH_MS = 80;
        // Periodic client render log (1/sec)
        try{
          const nowMs = (typeof now==='number'? now : performance.now());
          window.__lastClientBallLog = typeof window.__lastClientBallLog==='number' ? window.__lastClientBallLog : 0;
          if (nowMs - window.__lastClientBallLog > 1000) {
            window.__lastClientBallLog = nowMs;
            if (window.clientLog) window.clientLog('render', {
              ballPx: { x: Math.round(ball.x), y: Math.round(ball.y) },
              ballNorm: { x: Number(ballX.toFixed(3)), y: Number(ballY.toFixed(3)) },
              buf: buf.length,
              aT: Math.round(a._at)%10000, bT: Math.round(b._at)%10000, t: Number(t.toFixed(2)),
              side
            });
          }
        }catch(e){}

        const k = 1 - Math.exp(-dtMs / SMOOTH_MS);
        if (typeof window.__RENDER_SELF_Y !== 'number') window.__RENDER_SELF_Y = localTarget;
        window.__RENDER_SELF_Y = window.__RENDER_SELF_Y + (localTarget - window.__RENDER_SELF_Y) * k;

        if (side==='left') {
          if (window.player)   player.y   = window.__RENDER_SELF_Y;
          if (window.computer) computer.y = otherTargetRight;
        } else if (side==='right') {
          if (window.computer) computer.y = window.__RENDER_SELF_Y;
          if (window.player)   player.y   = otherTargetLeft;
        }
        if (window.ball){ ball.x = normToPxX(ballX); ball.y = normToPxYFull(ballY); }
      }
      function setupSocket(){
        if (sock) return;
        sock = io('/game');
        window.sock = sock;
        sock.on('connect', ()=>{ if (window.DEBUG_MP) console.log('[mp] socket connected', sock.id); window.clientLog && window.clientLog('connect', { id: sock.id, room: window.ROOM_ID }); });
        sock.on('disconnect', (r)=>{ if (window.DEBUG_MP) console.log('[mp] socket disconnected', r); window.clientLog && window.clientLog('disconnect', { reason: r }); });
        sock.emit('join', { roomId: window.ROOM_ID, name: 'Player' }, (ack)=>{
          side = ack && ack.side;
          if (window.DEBUG_MP) console.log('[mp] joined', { room: window.ROOM_ID, side, role: ack && ack.role, maxPlayers: ack && ack.maxPlayers });
          window.clientLog && window.clientLog('joined', { room: window.ROOM_ID, side, role: ack && ack.role, maxPlayers: ack && ack.maxPlayers });
        });
        sock.on('state', applyState);
        sock.on('gameState', applyState);
        // Clear buffer on reconnect
        sock.on('reconnect', ()=> { if (window.DEBUG_MP) console.log('[mp] reconnect, clearing buffer'); window.STATE_BUFFER = []; window.clientLog && window.clientLog('reconnect', {}); });
      }
      // Only auto-connect sockets if starting in multiplayer mode via query
      if (window.USE_MULTIPLAYER) setupSocket();
      // Hook key events to emit to server (simulation disabled in update())
      window.addEventListener('keydown', (e)=>{
        const k = e.key;
        if (k==='ArrowUp' || k==='w' || k==='W'){ startRepeat('up'); e.preventDefault(); }
        if (k==='ArrowDown' || k==='s' || k==='S'){ startRepeat('down'); e.preventDefault(); }
      });
      window.addEventListener('keyup', (e)=>{
        const k = e.key;
        if (k==='ArrowUp' || k==='w' || k==='W') stopRepeat('up');
        if (k==='ArrowDown' || k==='s' || k==='S') stopRepeat('down');
      });
    </script>


    <h1 class="text-3xl sm:text-5xl my-2 sm:mb-4 title">PONG</h1>

    <div class="flex w-full max-w-4xl justify-around mb-2 sm:mb-4">
        <div class="text-center">
            <h2 class="text-xl sm:text-2xl score-label">PLAYER</h2>
            <p id="player-score" class="text-4xl sm:text-6xl score">0</p>
        </div>
        <div class="text-center">
            <h2 class="text-xl sm:text-2xl score-label">COMPUTER</h2>
            <p id="computer-score" class="text-4xl sm:text-6xl score">0</p>
        </div>
    </div>

    <!-- Button to open speed modal -->
    <div class="text-center mb-4">
        <button id="speedButton" class="restart-btn py-2 px-4 rounded-lg text-sm">Ball Speed</button>
    </div>

    <div class="relative w-full max-w-4xl mt-2">
        <canvas id="pongCanvas" class="w-full"></canvas>
        <button id="muteButton" class="absolute top-4 right-4 text-white text-3xl focus:outline-none opacity-75 hover:opacity-100 transition-opacity">üîä</button>
    </div>

    <!-- Toast notification -->
    <div id="toast" class="toast"></div>

    <!-- Start Overlay (required for autoplay policies) -->
    <div id="startOverlay" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
        <div class="message-box rounded-lg p-8 text-center">
            <p class="text-2xl mb-6 text-white" style="text-shadow: 0 0 10px #00ffff;">Choose mode</p>
            <div class="space-y-4">
              <button id="startButton" class="restart-btn py-3 px-8 rounded-lg focus:outline-none focus:ring-2 focus:ring-white focus:ring-opacity-50 w-64">Multiplayer</button>
              <button id="startAIButton" class="restart-btn py-3 px-8 rounded-lg focus:outline-none focus:ring-2 focus:ring-white focus:ring-opacity-50 w-64">Single Player</button>
            </div>
        </div>
    </div>


    <!-- Custom Message Box -->
    <div id="messageBox" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center">
        <div class="message-box rounded-lg p-8 text-center">
            <p id="messageText" class="text-2xl mb-6 text-white" style="text-shadow: 0 0 10px #00ffff;"></p>
            <button id="restartButton" class="restart-btn py-3 px-6 rounded-lg focus:outline-none focus:ring-2 focus:ring-white focus:ring-opacity-50">
                Play Again
            </button>
        </div>
    </div>

    <!-- Speed Control Modal -->
    <div id="speedModal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
        <div class="message-box rounded-lg p-8 text-center">
            <label for="speedSlider" class="score-label text-2xl mb-4 block">Ball Speed</label>
            <div class="mt-2 flex flex-col items-center justify-center gap-4">
                <input id="speedSlider" type="range" min="0.5" max="2.0" step="0.05" value="1.0" class="w-full max-w-xs">
                <span id="speedValue" class="score text-2xl">1.00x</span>
            </div>
            <button id="closeSpeedModal" class="restart-btn mt-6 py-2 px-6 rounded-lg">Close</button>
        </div>
    </div>

    <!-- Countdown Display -->
    <div id="countdown" class="absolute inset-0 flex items-center justify-center text-white text-9xl font-bold" style="display: none; text-shadow: 0 0 20px #00ffff;"></div>

    <script>
        const canvas = document.getElementById('pongCanvas');
        const ctx = canvas.getContext('2d');

        // Lazy-load Tone.js only after a user gesture to avoid autoplay warnings
        let toneLoadPromise = null;
        function loadTone() {
            if (window.Tone) return Promise.resolve();
            if (toneLoadPromise) return toneLoadPromise;
            toneLoadPromise = new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = '/assets/pongo/vendor/tone/Tone.min.js';
                s.async = true;
                s.onload = () => resolve();
                s.onerror = (e) => reject(new Error('Failed to load Tone.js'));
                document.head.appendChild(s);
            });
            return toneLoadPromise;
        }

        const playerScoreElem = document.getElementById('player-score');
        const computerScoreElem = document.getElementById('computer-score');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');
        const muteButton = document.getElementById('muteButton');
        const speedButton = document.getElementById('speedButton');
        const speedModal = document.getElementById('speedModal');
        const closeSpeedModal = document.getElementById('closeSpeedModal');
        const countdownElem = document.getElementById('countdown');

        // --- Game Constants ---
        const PADDLE_WIDTH = 15;
        const PADDLE_HEIGHT = 100;
        const BALL_RADIUS = 10;
        const WINNING_SCORE = 5;
        const PADDLE_COLOR = '#00ffff';
        const BALL_COLOR = '#ffffff';
        const PADDLE_COLOR_SELF = '#ff00ff';
        const PADDLE_COLOR_OPP  = PADDLE_COLOR;

    // Tuning: how fast the ball accelerates after each paddle hit and max speed cap
    const SPEED_INCREMENT = 1.08; // was 1.05
    const MAX_SPEED_MULTIPLIER = 1.35; // was 1.2

// Speed multiplier controlled by UI slider (1.0 = default)
let speedMultiplier = 1.0;

// Hook up the slider after DOM elements exist; we'll query later during init
function setupSpeedSlider() {
    const slider = document.getElementById('speedSlider');
    const valueLabel = document.getElementById('speedValue');
    if (!slider || !valueLabel) return;

    // Initialize display and slider position
    slider.value = speedMultiplier;
    valueLabel.textContent = parseFloat(speedMultiplier).toFixed(2) + 'x';

    slider.addEventListener('input', (e) => {
        const v = parseFloat(e.target.value);
        speedMultiplier = v;
        valueLabel.textContent = v.toFixed(2) + 'x';
        // Apply multiplier to current ball velocities and maxSpeed
        if (ball) applySpeedMultiplierToBall(v);
    });

    // If a ball exists on setup, apply multiplier immediately
    if (ball) applySpeedMultiplierToBall(speedMultiplier);
}

function applySpeedMultiplierToBall(mult) {
    if (window.PongoCore && window.PongoCore.applySpeedMultiplierToBall) {
        window.PongoCore.applySpeedMultiplierToBall(ball, canvas.width, mult, MAX_SPEED_MULTIPLIER);
    }
}


        // Keyboard control state
        const keys = { up:false, down:false, left:false, right:false };
        let keyboardSpeedFactor = 1.1; // fraction of canvas height per second

        let ball, player, computer, gameRunning;
        let particles = [];

        // --- Enhanced Audio System ---
        let audioSystem = null;
        let audioReady = false;
        let isMuted = false;
        let canPlayHitSound = true;
        let canPlayWallSound = true;

        class AudioSystem {
            constructor() {
                this.sounds = {};
                this.effects = {};
                this.masterVolume = new Tone.Volume(-6).toDestination(); // Slight reduction for headroom
                this.pulseInterval = null;
                this.setupEffects();
                this.setupSounds();
                this.setupDynamics();
            }

            setupDynamics() {
                // Add subtle ducking when scoring sounds play
                this.duckingGain = new Tone.Gain(1);
                this.effects.reverb.disconnect();
                this.effects.reverb.connect(this.duckingGain);
                this.duckingGain.connect(this.masterVolume);
            }

            setupEffects() {
                // Create shared effects for better cohesion
                this.effects.reverb = new Tone.Reverb({
                    roomSize: 0.3,
                    dampening: 3000,
                    wet: 0.15
                }).connect(this.masterVolume);

                this.effects.delay = new Tone.PingPongDelay({
                    delayTime: "8n",
                    feedback: 0.1,
                    wet: 0.05
                }).connect(this.effects.reverb);

                this.effects.filter = new Tone.Filter({
                    frequency: 8000,
                    type: "lowpass",
                    rolloff: -12
                }).connect(this.effects.delay);

                this.effects.compressor = new Tone.Compressor({
                    threshold: -18,
                    ratio: 4,
                    attack: 0.003,
                    release: 0.1
                }).connect(this.effects.filter);
            }

            setupSounds() {
                // Enhanced paddle hit sound with FM synthesis
                this.sounds.paddleHit = new Tone.FMSynth({
                    harmonicity: 1.5,
                    modulationIndex: 8,
                    oscillator: { type: "sine" },
                    modulation: { type: "square" },
                    envelope: {
                        attack: 0.002,
                        decay: 0.08,
                        sustain: 0.1,
                        release: 0.15
                    },
                    modulationEnvelope: {
                        attack: 0.001,
                        decay: 0.05,
                        sustain: 0.2,
                        release: 0.1
                    }
                }).connect(this.effects.compressor);

                // Enhanced wall bounce with membrane synthesis and pitch bend
                this.sounds.wallBounce = new Tone.MembraneSynth({
                    pitchDecay: 0.02,
                    octaves: 3,
                    oscillator: { type: "sine" },
                    envelope: {
                        attack: 0.001,
                        decay: 0.15,
                        sustain: 0.02,
                        release: 0.2
                    }
                }).connect(this.effects.compressor);

                // Player score - triumphant arpeggio
                this.sounds.playerScore = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "sawtooth" },
                    envelope: {
                        attack: 0.01,
                        decay: 0.3,
                        sustain: 0.2,
                        release: 0.8
                    }
                }).connect(this.effects.reverb);

                // Computer score - darker chord
                this.sounds.computerScore = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "square" },
                    envelope: {
                        attack: 0.02,
                        decay: 0.4,
                        sustain: 0.15,
                        release: 0.6
                    }
                }).connect(this.effects.reverb);

                // Ambient background pad (subtle)
                this.sounds.ambient = new Tone.Synth({
                    oscillator: { type: "sine" },
                    envelope: {
                        attack: 2,
                        decay: 1,
                        sustain: 0.8,
                        release: 3
                    }
                }).connect(new Tone.Volume(-24).connect(this.effects.reverb));

                // Additional ambient layer with subtle movement
                this.sounds.ambientHigh = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: {
                        attack: 3,
                        decay: 2,
                        sustain: 0.6,
                        release: 4
                    }
                }).connect(new Tone.Volume(-28).connect(this.effects.reverb));

                // Subtle rhythmic pulse
                this.sounds.pulse = new Tone.Synth({
                    oscillator: { type: "sine" },
                    envelope: {
                        attack: 0.1,
                        decay: 0.3,
                        sustain: 0.1,
                        release: 0.5
                    }
                }).connect(new Tone.Volume(-30).connect(this.effects.reverb));

                // Game state transition sound
                this.sounds.transition = new Tone.Synth({
                    oscillator: { type: "sawtooth" },
                    envelope: {
                        attack: 0.05,
                        decay: 0.2,
                        sustain: 0.3,
                        release: 0.8
                    }
                }).connect(this.effects.reverb);

                // UI interaction sounds
                this.sounds.buttonClick = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: {
                        attack: 0.01,
                        decay: 0.1,
                        sustain: 0.1,
                        release: 0.2
                    }
                }).connect(new Tone.Volume(-12).connect(this.effects.compressor));

                this.sounds.buttonHover = new Tone.Synth({
                    oscillator: { type: "sine" },
                    envelope: {
                        attack: 0.005,
                        decay: 0.05,
                        sustain: 0.05,
                        release: 0.1
                    }
                }).connect(new Tone.Volume(-18).connect(this.effects.compressor));
            }

            playPaddleHit(ballSpeed, hitPosition) {
                if (!canPlayHitSound) return;

                // Dynamic pitch based on ball speed and hit position
                const baseNote = 60; // C4
                const speedFactor = Math.min(ballSpeed / 10, 2); // Normalize speed
                const positionFactor = (hitPosition + 1) * 0.5; // Convert -1 to 1 range to 0 to 1
                const pitch = baseNote + (speedFactor * 12) + (positionFactor * 7);

                // Add slight random variation for more organic feel
                const variation = (Math.random() - 0.5) * 2; // ¬±1 semitone
                const finalPitch = pitch + variation;

                const note = Tone.Frequency(finalPitch, "midi").toNote();
                const duration = Math.max(0.05, 0.15 - speedFactor * 0.05);

                // Adjust FM synthesis parameters based on hit intensity
                this.sounds.paddleHit.harmonicity.value = 1.5 + (speedFactor * 0.5);
                this.sounds.paddleHit.modulationIndex.value = 8 + (speedFactor * 4);

                this.sounds.paddleHit.triggerAttackRelease(note, duration, Tone.now() + 0.01);

                // Visual feedback - brief screen flash
                this.createAudioVisualFeedback('paddle', speedFactor);

                canPlayHitSound = false;
                setTimeout(() => { canPlayHitSound = true; }, 80);
            }

            playWallBounce(ballSpeed, yPosition, canvasHeight) {
                if (!canPlayWallSound) return;

                // Dynamic pitch based on ball speed and wall position
                const baseNote = 36; // C2
                const speedFactor = Math.min(ballSpeed / 10, 2);
                const positionFactor = yPosition / canvasHeight; // 0 to 1 from top to bottom

                // Higher pitch for top wall, lower for bottom
                const positionPitch = positionFactor < 0.5 ? 6 : -3;
                const pitch = baseNote + (speedFactor * 8) + positionPitch;

                // Add impact variation
                const impactVariation = (Math.random() - 0.5) * 3;
                const finalPitch = pitch + impactVariation;

                const note = Tone.Frequency(finalPitch, "midi").toNote();

                // Adjust membrane parameters for more impact
                this.sounds.wallBounce.pitchDecay = 0.02 + (speedFactor * 0.01);
                this.sounds.wallBounce.octaves = 3 + (speedFactor * 1);

                // Vary duration based on impact force
                // Use musical notation strings directly; avoid Math.max on strings
                const duration = speedFactor > 1 ? "8n" : "16n";

                this.sounds.wallBounce.triggerAttackRelease(note, duration, Tone.now() + 0.01);

                // Visual feedback - wall flash
                this.createAudioVisualFeedback('wall', speedFactor, positionFactor);

                canPlayWallSound = false;
                setTimeout(() => { canPlayWallSound = true; }, 100);
            }

            playPlayerScore() {
                // Duck ambient sounds slightly
                this.duckAmbient(0.7, 2);

                // Visual feedback for player scoring
                this.createAudioVisualFeedback('score', 0.8);

                // Triumphant major arpeggio with ascending melody
                const baseNote = 72; // C5
                const arpeggio = [0, 4, 7, 12, 16]; // C major arpeggio going up two octaves

                // Play the main arpeggio
                arpeggio.forEach((interval, index) => {
                    const note = Tone.Frequency(baseNote + interval, "midi").toNote();
                    this.sounds.playerScore.triggerAttackRelease(
                        note,
                        "8n",
                        Tone.now() + 0.02 + (index * 0.08)
                    );
                });

                // Add a celebratory chord at the end
                const finalChord = [0, 4, 7].map(interval =>
                    Tone.Frequency(baseNote + 12 + interval, "midi").toNote()
                );
                this.sounds.playerScore.triggerAttackRelease(
                    finalChord,
                    "2n",
                    Tone.now() + 0.5
                );
            }

            playComputerScore() {
                // Duck ambient sounds slightly
                this.duckAmbient(0.6, 2.5);

                // Visual feedback for computer scoring (more subtle)
                this.createAudioVisualFeedback('score', 0.5);

                // Darker, more ominous sound with descending pattern
                const baseNote = 55; // G3
                const descending = [12, 8, 5, 3, 0]; // Descending minor pattern

                // Play descending notes
                descending.forEach((interval, index) => {
                    const note = Tone.Frequency(baseNote + interval, "midi").toNote();
                    this.sounds.computerScore.triggerAttackRelease(
                        note,
                        "8n",
                        Tone.now() + 0.02 + (index * 0.12)
                    );
                });

                // Add a final minor chord
                const finalChord = [0, 3, 7].map(interval =>
                    Tone.Frequency(baseNote + interval, "midi").toNote()
                );
                this.sounds.computerScore.triggerAttackRelease(
                    finalChord,
                    "2n",
                    Tone.now() + 0.7
                );
            }

            duckAmbient(level, duration) {
                // Temporarily reduce ambient volume for scoring sounds
                this.duckingGain.gain.rampTo(level, 0.1);
                setTimeout(() => {
                    this.duckingGain.gain.rampTo(1, 0.5);
                }, duration * 1000);
            }

            startAmbient() {
                // Subtle ambient drone with multiple layers
                this.sounds.ambient.triggerAttack("C2", Tone.now());
                this.sounds.ambientHigh.triggerAttack("G3", Tone.now() + 1);

                // Start subtle pulse
                this.startPulse();
            }

            stopAmbient() {
                this.sounds.ambient.triggerRelease(Tone.now() + 1);
                this.sounds.ambientHigh.triggerRelease(Tone.now() + 1.5);
                this.stopPulse();
            }

            startPulse() {
                if (this.pulseInterval) return;

                const playPulse = () => {
                    if (!isMuted && gameRunning) {
                        this.sounds.pulse.triggerAttackRelease("C1", "32n", Tone.now());
                    }
                };

                // Very subtle pulse every 4 seconds
                this.pulseInterval = setInterval(playPulse, 4000);
            }

            stopPulse() {
                if (this.pulseInterval) {
                    clearInterval(this.pulseInterval);
                    this.pulseInterval = null;
                }
            }

            playGameStart() {
                // Subtle upward sweep when game starts
                this.sounds.transition.triggerAttackRelease("C3", "2n", Tone.now());
            }

            playGameEnd() {
                // Downward sweep when game ends
                this.sounds.transition.triggerAttackRelease("C2", "1n", Tone.now());
            }

            playButtonClick() {
                // Subtle click sound for buttons
                this.sounds.buttonClick.triggerAttackRelease("C5", "16n", Tone.now());
            }

            playButtonHover() {
                // Very subtle hover sound
                this.sounds.buttonHover.triggerAttackRelease("G5", "32n", Tone.now());
            }

            createAudioVisualFeedback(type, intensity, position = 0.5) {
                // Create subtle visual feedback that responds to audio
                const canvas = document.getElementById('pongCanvas');
                if (!canvas) return;

                switch (type) {
                    case 'paddle':
                        // Brief screen edge glow
                        this.flashScreenEdge(intensity * 0.3, 100);
                        break;
                    case 'wall':
                        // Flash the wall area
                        this.flashWallArea(position, intensity * 0.4, 150);
                        break;
                    case 'score':
                        // Full screen subtle flash
                        this.flashScreen(intensity * 0.2, 300);
                        break;
                }
            }

            flashScreenEdge(opacity, duration) {
                const canvas = document.getElementById('pongCanvas');
                const originalBoxShadow = canvas.style.boxShadow;
                canvas.style.boxShadow = `0 0 20px rgba(0, 255, 255, ${opacity})`;
                setTimeout(() => {
                    canvas.style.boxShadow = originalBoxShadow;
                }, duration);
            }

            flashWallArea(position, opacity, duration) {
                // Create a temporary overlay for wall flash
                const canvas = document.getElementById('pongCanvas');
                const overlay = document.createElement('div');
                overlay.style.position = 'absolute';
                overlay.style.top = position < 0.5 ? '0' : 'auto';
                overlay.style.bottom = position >= 0.5 ? '0' : 'auto';
                overlay.style.left = '0';
                overlay.style.right = '0';
                overlay.style.height = '5px';
                overlay.style.backgroundColor = `rgba(255, 255, 255, ${opacity})`;
                overlay.style.pointerEvents = 'none';
                overlay.style.zIndex = '10';

                canvas.parentElement.appendChild(overlay);
                setTimeout(() => {
                    if (overlay.parentElement) {
                        overlay.parentElement.removeChild(overlay);
                    }
                }, duration);
            }

            flashScreen(opacity, duration) {
                const body = document.body;
                const originalFilter = body.style.filter;
                body.style.filter = `brightness(${1 + opacity})`;
                setTimeout(() => {
                    body.style.filter = originalFilter;
                }, duration);
            }

            dispose() {
                // Clean up pulse interval
                this.stopPulse();

                // Dispose of all audio nodes
                Object.values(this.sounds).forEach(sound => {
                    if (sound && typeof sound.dispose === 'function') {
                        sound.dispose();
                    }
                });
                Object.values(this.effects).forEach(effect => {
                    if (effect && typeof effect.dispose === 'function') {
                        effect.dispose();
                    }
                });

                if (this.masterVolume && typeof this.masterVolume.dispose === 'function') {
                    this.masterVolume.dispose();
                }
                if (this.duckingGain && typeof this.duckingGain.dispose === 'function') {
                    this.duckingGain.dispose();
                }
            }
        }

        function setupAudio() {
            if (!window.Tone) return;
            if (audioSystem) return;

            try {
                audioSystem = new AudioSystem();
                console.log("Enhanced audio system initialized");
            } catch (error) {
                console.warn("Failed to initialize audio system:", error);
            }
        }

        // --- Layout helpers ---
        function getCanvasSize() {
            if (window.PongoCore && window.PongoCore.getCanvasSize) {
                return window.PongoCore.getCanvasSize(canvas);
            }
            return { width: canvas.width || 800, height: canvas.height || 450 };
        }

        // --- Game Objects Initialization ---
        function initGameObjects() {
            const size = getCanvasSize();
            canvas.width = size.width;
            canvas.height = size.height;

            // Speeds are in pixels per second (frame-rate independent)
            const BASE_SPEED = canvas.width * 0.7 * speedMultiplier; // crosses ~1.4s
            const angle = Math.PI / 4; // 45 degrees
            const dirX = Math.random() > 0.5 ? 1 : -1;
            const dirY = Math.random() > 0.5 ? 1 : -1;

            ball = {
                x: canvas.width / 2,
                y: canvas.height / 2,
                radius: BALL_RADIUS,
                vx: 0,
                vy: 0,
                maxSpeed: canvas.width * MAX_SPEED_MULTIPLIER * speedMultiplier
            };
            player = { x: 10, y: canvas.height / 2 - PADDLE_HEIGHT / 2, width: PADDLE_WIDTH, height: PADDLE_HEIGHT, score: 0 };
            computer = { x: canvas.width - 10 - PADDLE_WIDTH, y: canvas.height / 2 - PADDLE_HEIGHT / 2, width: PADDLE_WIDTH, height: PADDLE_HEIGHT, score: 0, maxSpeed: canvas.height * 0.9 };

            gameRunning = true;

            // Start ambient audio when game begins
            if (audioReady && audioSystem && !isMuted) {
                audioSystem.playGameStart();
                setTimeout(() => {
                    if (gameRunning && !isMuted) {
                        audioSystem.startAmbient();
                    }
                }, 500);
            }
            // Wire up speed slider UI (idempotent)
            setupSpeedSlider();
        }

        // --- Drawing Functions ---
        function drawRect(x, y, w, h, color) {
            if (window.PongoCore && window.PongoCore.drawRect) return window.PongoCore.drawRect(ctx, x, y, w, h, color);
        }

        function drawCircle(x, y, r, color) {
            if (window.PongoCore && window.PongoCore.drawCircle) return window.PongoCore.drawCircle(ctx, x, y, r, color);
        }

        function drawNet() {
            if (window.PongoCore && window.PongoCore.drawNet) return window.PongoCore.drawNet(ctx, canvas);
        }

        // --- Particle System ---
        function createParticles(x, y, color) {
            if (window.PongoCore && window.PongoCore.createParticles) return window.PongoCore.createParticles(particles, x, y, color);
        }

        function updateAndDrawParticles() {
            if (window.PongoCore && window.PongoCore.updateAndDrawParticles) return window.PongoCore.updateAndDrawParticles(particles, ctx);
        }

        // --- Game Logic ---
        function resetBall(launch = true) {
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            ball.vx = 0;
            ball.vy = 0;
            ball.maxSpeed = canvas.width * MAX_SPEED_MULTIPLIER * speedMultiplier;

            if (launch && !window.USE_MULTIPLAYER) {
                startCountdown();
            }
        }

        function launchBall() {
            const BASE_SPEED = canvas.width * 0.7 * speedMultiplier;
            const angle = Math.PI / 4;
            const dirX = Math.random() > 0.5 ? 1 : -1;
            const dirY = Math.random() > 0.5 ? 1 : -1;
            ball.vx = dirX * BASE_SPEED * Math.cos(angle);
            ball.vy = dirY * BASE_SPEED * Math.sin(angle);
        }

        function startCountdown() {
            let count = 3;
            countdownElem.textContent = count;
            countdownElem.style.display = 'flex';

            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownElem.textContent = count;
                } else {
                    clearInterval(countdownInterval);
                    countdownElem.style.display = 'none';
                    launchBall();
                }
            }, 1000);
        }

        function update(dt) {
            if (window.USE_MULTIPLAYER) return;
            if (!gameRunning) return;

            // Move ball
            ball.x += ball.vx * dt;
            ball.y += ball.vy * dt;

            // Move computer paddle
            const target = ball.y - (computer.height / 2);
            const diff = target - computer.y;
            const step = computer.maxSpeed * dt;
            if (Math.abs(diff) <= step) {
                computer.y = target;
            } else {


                computer.y += Math.sign(diff) * step;
            }
            if (computer.y < 0) computer.y = 0;
            if (computer.y > canvas.height - computer.height) computer.y = canvas.height - computer.height;


            // Player keyboard control (Arrow/W/S)
            {
                const speed = canvas.height * keyboardSpeedFactor;
                if (keys.up) player.y -= speed * dt;
                if (keys.down) player.y += speed * dt;
                if (player.y < 0) player.y = 0;
                if (player.y > canvas.height - player.height) player.y = canvas.height - player.height;
            }

            // Ball collision with top/bottom walls
            if ((ball.y + ball.radius > canvas.height && ball.vy > 0) || (ball.y - ball.radius < 0 && ball.vy < 0)) {
                if (ball.y + ball.radius > canvas.height) ball.y = canvas.height - ball.radius;
                else ball.y = ball.radius;

                ball.vy *= -1;



                if (audioReady && window.Tone && Tone.context.state === 'running' && audioSystem) {
                    const ballSpeed = Math.sqrt(ball.vx**2 + ball.vy**2);
                    audioSystem.playWallBounce(ballSpeed, ball.y, canvas.height);
                }
                createParticles(ball.x, ball.y, 'rgba(255, 255, 255, 0.5)');
            }

            // Ball collision with paddles
            let paddle = (ball.x < canvas.width / 2) ? player : computer;
            if (collision(ball, paddle)) {
                let collidePoint = (ball.y - (paddle.y + paddle.height / 2)) / (paddle.height / 2);

                if (audioReady && window.Tone && Tone.context.state === 'running' && audioSystem) {
                    const ballSpeed = Math.sqrt(ball.vx**2 + ball.vy**2);
                    audioSystem.playPaddleHit(ballSpeed, collidePoint);
                }

                createParticles(ball.x, ball.y, PADDLE_COLOR);

                let angleRad = (Math.PI / 4) * collidePoint;
                let direction = (ball.x < canvas.width / 2) ? 1 : -1;

                let currentSpeed = Math.sqrt(ball.vx**2 + ball.vy**2);
                let newSpeed = Math.min(ball.maxSpeed, currentSpeed * SPEED_INCREMENT);

                ball.vx = direction * newSpeed * Math.cos(angleRad);
                ball.vy = newSpeed * Math.sin(angleRad);

                if(direction === 1) ball.x = player.x + player.width + ball.radius;
                else ball.x = computer.x - ball.radius;
            }

            // Scoring
            if (ball.x - ball.radius < 0) {
                if (audioReady && window.Tone && Tone.context.state === 'running' && audioSystem) {
                    audioSystem.playComputerScore();
                }
                computer.score++;
                updateScores();
                resetBall();
            } else if (ball.x + ball.radius > canvas.width) {
                if (audioReady && window.Tone && Tone.context.state === 'running' && audioSystem) {
                    audioSystem.playPlayerScore();
                }
                player.score++;
                updateScores();
                resetBall();
            }

            checkWinner();
        }

        function collision(b, p) {
            return b.x + b.radius > p.x && b.x - b.radius < p.x + p.width &&
                   b.y + b.radius > p.y && b.y - b.radius < p.y + p.height;
        }

        function updateScores() {
            playerScoreElem.textContent = player.score;
            computerScoreElem.textContent = computer.score;
        }

        function checkWinner() {
            if (player.score >= WINNING_SCORE) endGame("You Win!");
            else if (computer.score >= WINNING_SCORE) endGame("Computer Wins!");
        }

        function endGame(message) {
            gameRunning = false;
            messageText.textContent = message;
            messageBox.classList.remove('hidden');

            // Stop ambient audio when game ends
            if (audioSystem) {
                audioSystem.playGameEnd();
                audioSystem.stopAmbient();
            }
        }

    function render() {
            ctx.fillStyle = 'rgba(15, 12, 41, 0.25)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawNet();
            // Choose colors: your paddle highlighted
            let leftColor = PADDLE_COLOR;
            let rightColor = PADDLE_COLOR;
            if (window.USE_MULTIPLAYER) {
                if (typeof side === 'string') {
                    if (side === 'left') leftColor = PADDLE_COLOR_SELF; else if (side === 'right') rightColor = PADDLE_COLOR_SELF;
                }
            } else {
                leftColor = PADDLE_COLOR_SELF; // AI mode: you are the left paddle
            }
            drawRect(player.x, player.y, player.width, player.height, leftColor);
            drawRect(computer.x, computer.y, computer.width, computer.height, rightColor);
            drawCircle(ball.x, ball.y, ball.radius, BALL_COLOR);
            updateAndDrawParticles();
        }

        let lastTime = performance.now();
        function gameLoop(now) {
            if (now === undefined) now = performance.now();
            const dt = Math.min((now - lastTime) / 1000, 0.033); // cap to avoid huge jumps
            lastTime = now;
            if (gameRunning) update(dt);
            if (window.USE_MULTIPLAYER) { try { stepMultiplayer(now); } catch(e){} }
            render();
            requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners & Game Start ---
        async function startAudioContext() {
            try {
                if (!window.Tone) {
                    console.warn('Tone.js not loaded; continuing without audio.');
                    audioReady = false;
                    // Disable mute button when audio is unavailable
                    muteButton.setAttribute('aria-disabled', 'true');
                    muteButton.style.opacity = '0.5';
                    return;
                }
                if (Tone.context.state !== 'running') {
                    await Tone.start();
                    console.log("Audio context started.");
                }


                setupAudio();
                audioReady = (Tone.context.state === 'running');
            } catch (e) {
                console.warn('Failed to start audio context', e);
            }
        }

        // Toast notification function
        function showToast(message, duration = 3000) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, duration);
        }

        // Start overlay interactions
        const startOverlay = document.getElementById('startOverlay');
        const startButton = document.getElementById('startButton');

        const startAIButton = document.getElementById('startAIButton');

        // Online start uses multiplayer and shows waiting overlay if needed
        async function handleStart(){ return handleStartOnline(); }
        startButton.addEventListener('click', async () => {
            if (window.DEBUG_MP) console.log('[ui] Start button clicked (Online)');
            if (audioSystem) audioSystem.playButtonClick();

            // Auto-copy room link for multiplayer
            const url = window.location.href;
            try {
                await navigator.clipboard.writeText(url);
                showToast('Room link copied to clipboard!');
            } catch (err) {
                // Fallback if Clipboard API unavailable
                showToast('Room link: ' + url);
            }

            handleStartOnline();
        });
        if (startAIButton) startAIButton.addEventListener('click', () => {
            if (audioSystem) audioSystem.playButtonClick();
            handleStartAI();
        });
        startOverlay.addEventListener('click', (e) => {
            // allow clicking outside button to start as well
            if (e.target === startOverlay) {
                if (audioSystem) audioSystem.playButtonClick();
                handleStart();
            }


        });


        function movePlayer(event) {
            if (window.USE_MULTIPLAYER) return; // ignore local mouse/touch in multiplayer
            let rect = canvas.getBoundingClientRect();
            let clientY = event.touches ? event.touches[0].clientY : event.clientY;
            player.y = clientY - rect.top - player.height / 2;
            if (player.y < 0) player.y = 0;
            if (player.y > canvas.height - player.height) player.y = canvas.height - player.height;
        }

        async function handleStartOnline(){
            try { await loadTone(); } catch(e) { console.warn('Tone.js failed to load; continuing without audio.', e); }
            await startAudioContext();
            startOverlay.classList.add('hidden');
            window.USE_MULTIPLAYER = true;
            setupSocket();
            if (window.DEBUG_MP) console.log('[ui] Play Online clicked -> multiplayer mode');
            // Show waiting UI until server starts the round
            const WAIT_MSG = `Waiting for another player to join${window.ROOM_ID?` in room \u201c${window.ROOM_ID}\u201d`:''}\u2026`;
            const last = window.STATE_BUFFER && window.STATE_BUFFER[window.STATE_BUFFER.length-1];
            if (!last || last.roundState === 'waiting') {
                const box = document.getElementById('messageBox');
                const text = document.getElementById('messageText');
                const btn = document.getElementById('restartButton');
                if (box && text && btn) { box.classList.remove('hidden'); text.textContent = WAIT_MSG; btn.classList.add('hidden'); }
            }
        }
        async function handleStartAI(){
            try { await loadTone(); } catch(e) { console.warn('Tone.js failed to load; continuing without audio.', e); }
            await startAudioContext();
            startOverlay.classList.add('hidden');
            window.USE_MULTIPLAYER = false;
            if (window.DEBUG_MP) console.log('[ui] Play vs AI clicked -> single-player mode');
            // Hide any waiting overlay
            const box = document.getElementById('messageBox'); const btn = document.getElementById('restartButton');
            if (box) box.classList.add('hidden'); if (btn) btn.classList.remove('hidden');
            if (!gameRunning) {
                initGameObjects();
                startCountdown();
            }
        }

        if (!window.USE_MULTIPLAYER) {
            canvas.addEventListener('mousemove', movePlayer);
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                movePlayer(e);
            }, {passive: false});
        }

        // Keyboard listeners (top-level) only for local single-player
        if (!window.USE_MULTIPLAYER) {
            window.addEventListener('keydown', (e) => {
                const k = e.key;
                if (k === 'ArrowUp' || k === 'w' || k === 'W') { keys.up = true; e.preventDefault(); }
                if (k === 'ArrowDown' || k === 's' || k === 'S') { keys.down = true; e.preventDefault(); }
                if (k === 'ArrowLeft' || k === 'a' || k === 'A') { keys.left = true; }
                if (k === 'ArrowRight' || k === 'd' || k === 'D') { keys.right = true; }
            });
            window.addEventListener('keyup', (e) => {
                const k = e.key;
                if (k === 'ArrowUp' || k === 'w' || k === 'W') keys.up = false;
                if (k === 'ArrowDown' || k === 's' || k === 'S') keys.down = false;
                if (k === 'ArrowLeft' || k === 'a' || k === 'A') keys.left = false;
                if (k === 'ArrowRight' || k === 'd' || k === 'D') keys.right = false;
            });
        }



        muteButton.addEventListener('click', () => {
            if (!window.Tone) return; // no audio available
            if (!audioReady) startAudioContext(); // Ensure audio is ready after user gesture

            // Play click sound before muting (if not already muted)
            if (audioSystem && !isMuted) audioSystem.playButtonClick();

            isMuted = !isMuted;
            Tone.Destination.mute = isMuted;
            muteButton.textContent = isMuted ? 'üîá' : 'üîä';

            // Handle ambient audio based on mute state
            if (audioSystem && gameRunning) {
                if (isMuted) {
                    audioSystem.stopAmbient();
                } else {
                    audioSystem.startAmbient();
                }
            }
        });

        restartButton.addEventListener('click', () => {
            if (audioSystem && !isMuted) audioSystem.playButtonClick();
            messageBox.classList.add('hidden');
            initGameObjects();
            updateScores();
        });

        // Speed modal functionality
        speedButton.addEventListener('click', () => {
            speedModal.classList.remove('hidden');
        });

        closeSpeedModal.addEventListener('click', () => {
            speedModal.classList.add('hidden');
        });

        // Preserve state on resize and keep canvas fully on-screen
        let resizeRaf = null;
        function resizeCanvasPreserveState() {
            const oldW = canvas.width;
            const oldH = canvas.height;
            const { width: newW, height: newH } = getCanvasSize();
            if (oldW === newW && oldH === newH) return;

            const scaleX = newW / oldW;
            const scaleY = newH / oldH;

            canvas.width = newW;
            canvas.height = newH;

            // Scale positions
            if (ball) {
                ball.x *= scaleX;
                ball.y *= scaleY;
                ball.vx *= scaleX; // keep px/s scaled with canvas size
                ball.vy *= scaleY;
                ball.maxSpeed = canvas.width * MAX_SPEED_MULTIPLIER * speedMultiplier;
            }
            if (player) {
                player.y *= scaleY;
                if (player.y < 0) player.y = 0;
                if (player.y > canvas.height - player.height) player.y = canvas.height - player.height;
                player.x = 10;
            }
            if (computer) {
                computer.y *= scaleY;
                if (computer.y < 0) computer.y = 0;
                if (computer.y > canvas.height - computer.height) computer.y = canvas.height - computer.height;
                computer.x = canvas.width - 10 - computer.width;
                computer.maxSpeed = canvas.height * 0.9;
            }
        }

        function handleResize() {
            if (resizeRaf) cancelAnimationFrame(resizeRaf);
            resizeRaf = requestAnimationFrame(resizeCanvasPreserveState);
        }
        window.addEventListener('resize', handleResize);

        // Clean up audio system when page is unloaded
        window.addEventListener('beforeunload', () => {
            if (audioSystem) {
                audioSystem.dispose();
            }
        });

        initGameObjects();
        gameLoop();
    </script>
</body>
</html>


